"""
FILTRO DE TIMING RIGOROSO PARA TENNIS IQ
        print(f"üîÑ Buscando partidas ao vivo...")
        print(f"üì° API: {base_url}")
        print(f"üîë Token: {api_key[:10]}...{api_key[-5:]}")
        print(f"üéæ Sport ID: {params['sport_id']}")
        
        response = requests.get(url, params=params, headers=headers, timeout=15)
        print(f"üìä Status: {response.status_code}")
        
        if response.status_code == 200:
            try:
                data = response.json()
                print(f"üîç Response keys: {list(data.keys())}")
                
                if data.get('success') == '1' or data.get('success') == 1:
                    eventos = data.get('results', [])
                    print(f"‚úÖ Sucesso: {len(eventos)} partidas encontradas")
                    
                    if len(eventos) == 0:
                        print("‚ö†Ô∏è  Nenhuma partida de t√™nis ao vivo no momento")
                        return [] filtra partidas baseado em timing e prioridade de entrada.
S√≥ aprova partidas com prioridade ‚â•4 (2¬∫ set meio/final).

PRIORIDADES:
- 5: 3¬∫ set (qualquer ponto) - EXCELENTE
- 4: 2¬∫ set meio/final (3-3+) - √ìTIMO  
- 3: 2¬∫ set in√≠cio (0-0 at√© 2-2) - BOM (M√çNIMO ACEITO)
- 2: 1¬∫ set meio (3-3+) - POSS√çVEL (REJEITADO)
- 1: 1¬∫ set in√≠cio (0-0 at√© 2-2) - CEDO (REJEITADO)
- 0: Tie-break/Match point - EVITAR (REJEITADO)
"""

import json
import requests
import os
from datetime import datetime
import re

def buscar_partidas_ao_vivo():
    """Busca todas as partidas de t√™nis ao vivo usando API B365."""
    try:
        # Carregar configura√ß√£o da API
        config_path = os.path.join(os.path.dirname(__file__), '..', '..', 'config', 'config.json')
        with open(config_path, 'r') as f:
            config = json.load(f)
        
        api_key = config.get('api_key')
        base_url = config.get('api_base_url', 'https://api.b365api.com')
        
        if not api_key:
            print("‚ùå API key n√£o encontrada na configura√ß√£o")
            return _gerar_dados_simulados()
        
        # Endpoint para eventos ao vivo de t√™nis
        url = f"{base_url}/v3/events/inplay"
        params = {
            'token': api_key,
            'sport_id': 13  # T√™nis
        }
        
        headers = {
            'User-Agent': 'TennisIQ Bot 1.0',
            'Accept': 'application/json'
        }
        
        print(f"üîÑ Buscando partidas ao vivo...")
        print(f"ÔøΩ API: {base_url}")
        
        response = requests.get(url, params=params, headers=headers, timeout=15)
        print(f"ÔøΩ Status: {response.status_code}")
        
        if response.status_code == 200:
            data = response.json()
            
            if data.get('success') in ['1', 1]:
                eventos = data.get('results', [])
                print(f"‚úÖ Sucesso: {len(eventos)} partidas encontradas")
                
                # Converter formato B365 para formato interno
                eventos_convertidos = []
                for evento in eventos:
                    evento_convertido = {
                        'id': evento.get('id', ''),
                        'league': {'name': evento.get('league', {}).get('name', 'Liga n√£o informada')},
                        'home': {'name': evento.get('home', {}).get('name', 'Jogador 1')},
                        'away': {'name': evento.get('away', {}).get('name', 'Jogador 2')},
                        'ss': evento.get('ss', ''),
                        'sport_id': 13,  # T√™nis na API B365
                        'time': evento.get('time', ''),
                        'timer': evento.get('timer', {}),
                        'stats': evento.get('stats', {})
                    }
                    eventos_convertidos.append(evento_convertido)
                
                return eventos_convertidos
            else:
                error_msg = data.get('error', 'Erro desconhecido')
                print(f"‚ùå API Error: {error_msg}")
                print(f"üîç Full response: {data}")
                return []
                
        elif response.status_code == 401:
            print(f"üîê Erro de autoriza√ß√£o (401) - Verifique a API key")
            return []
        elif response.status_code == 403:
            print(f"üö´ Acesso negado (403) - API key inv√°lida")
            return []
        elif response.status_code == 429:
            print(f"‚è∞ Rate limit atingido (429) - Aguarde")
            return []
        else:
            print(f"‚ö†Ô∏è  C√≥digo HTTP: {response.status_code}")
            try:
                error_text = response.text[:200]
                print(f"üîç Response: {error_text}...")
            except:
                pass
            return []
        
    except FileNotFoundError:
        print("‚ùå Arquivo de configura√ß√£o n√£o encontrado")
        return []
    except json.JSONDecodeError:
        print("‚ùå Erro ao decodificar JSON da API")
        return []
    except Exception as e:
        print(f"‚ùå Erro ao buscar partidas: {e}")
        return []

def _gerar_dados_simulados():
    """Gera dados simulados para teste quando a API n√£o funciona"""
    return [
        {
            'id': 'sim001',
            'league': {'name': 'ATP Masters'},
            'home': {'name': 'Djokovic'},
            'away': {'name': 'Nadal'},
            'ss': '6-4, 3-2',
            'sport_id': 13  # T√™nis na API B365
        },
        {
            'id': 'sim002', 
            'league': {'name': 'WTA Tour'},
            'home': {'name': 'Williams'},
            'away': {'name': 'Sharapova'},
            'ss': '1-2',
            'sport_id': 13  # T√™nis na API B365
        },
        {
            'id': 'sim003',
            'league': {'name': 'ATP Challenger'},
            'home': {'name': 'Federer'},
            'away': {'name': 'Murray'},
            'ss': '6-3, 2-6, 4-3',
            'sport_id': 13  # T√™nis na API B365
        }
    ]

def analisar_fase_jogo(placar_str):
    """
    Analisa a fase do jogo e retorna:
    - fase: Descri√ß√£o textual da fase
    - entrada_segura: Se √© seguro entrar neste momento
    - prioridade: N√≠vel de prioridade (0-5)
    """
    
    if not placar_str or placar_str.strip() == '':
        return "Placar n√£o dispon√≠vel", False, 0
    
    placar = placar_str.strip()
    
    try:
        # Match terminado - EVITAR
        if any(keyword in placar.lower() for keyword in ['finished', 'finalizado', 'ended']):
            return "Partida finalizada", False, 0
        
        # Tie-break detectado - EVITAR (muito vol√°til)
        if '(' in placar and ')' in placar:
            return "Tie-break em andamento", False, 0
        
        # Match point - EVITAR (resultado pode sair a qualquer momento)
        if re.search(r'[56]-[56]', placar):
            # Verificar se h√° match point (um jogador com 6 e outro com 5)
            if '6-5' in placar or '5-6' in placar:
                return "Match point detectado", False, 0
        
        # Extrair sets do placar (formato: "6-4, 2-3" ou "6-4 2-3")
        sets = re.findall(r'(\d+)-(\d+)', placar)
        
        if not sets:
            return "Formato de placar inv√°lido", False, 0
        
        num_sets = len(sets)
        set_atual = sets[-1]  # √öltimo set (em andamento)
        games_p1, games_p2 = int(set_atual[0]), int(set_atual[1])
        
        # ===== AN√ÅLISE POR N√öMERO DE SETS =====
        
        if num_sets >= 3:
            # 3¬∫ SET OU MAIS - PRIORIDADE M√ÅXIMA
            return f"3¬∫ set: {games_p1}-{games_p2}", True, 5
            
        elif num_sets == 2:
            # 2¬∫ SET - AVALIAR PROGRESSO
            total_games = games_p1 + games_p2
            
            if total_games >= 6:  # 3-3 para cima
                return f"2¬∫ set meio/final: {games_p1}-{games_p2}", True, 4
            else:  # 0-0 at√© 2-2
                return f"2¬∫ set in√≠cio: {games_p1}-{games_p2}", True, 3
                
        elif num_sets == 1:
            # 1¬∫ SET - GERALMENTE CEDO DEMAIS
            total_games = games_p1 + games_p2
            
            if total_games >= 6:  # 3-3 para cima
                return f"1¬∫ set meio: {games_p1}-{games_p2}", False, 2
            else:  # 0-0 at√© 2-2
                return f"1¬∫ set in√≠cio: {games_p1}-{games_p2}", False, 1
        
        else:
            return "In√≠cio da partida", False, 1
            
    except Exception as e:
        return f"Erro na an√°lise: {str(e)}", False, 0

def filtrar_partidas_por_timing():
    """
    FILTRO DE TIMING RIGOROSO - S√≥ aprova partidas com prioridade ‚â•4 (2¬∫ set meio/final).
    """
    
    print("üî¥ FILTRO DE TIMING RIGOROSO ATIVADO")
    print("=" * 60)
    
    # Buscar eventos ao vivo
    eventos_ao_vivo = buscar_partidas_ao_vivo()
    
    if not eventos_ao_vivo:
        print("‚ùå Nenhuma partida ao vivo encontrada no momento.")
        return []
    
    partidas_filtradas = []
    
    print(f"üéæ TOTAL DE PARTIDAS ENCONTRADAS: {len(eventos_ao_vivo)}")
    print(f"üìÖ Data: {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
    print("")
    print("üî¥ FILTRO RIGOROSO: S√≥ aprova prioridade ‚â•4")
    print("=" * 80)
    
    for i, evento in enumerate(eventos_ao_vivo, 1):
        # Extrair informa√ß√µes b√°sicas
        evento_id = evento.get('id', 'N/A')
        liga = evento.get('league', {}).get('name', 'Liga n√£o informada')
        
        # Jogadores
        jogador_casa = evento.get('home', {}).get('name', 'Jogador 1')
        jogador_visitante = evento.get('away', {}).get('name', 'Jogador 2')
        
        # Placar b√°sico do evento principal
        ss_basico = evento.get('ss', '')
        
        # AN√ÅLISE RIGOROSA DE TIMING - USAR VALORES REAIS
        fase, entrada_segura, prioridade = analisar_fase_jogo(ss_basico)
        
        # Criar objeto da partida
        partida_info = {
            'id': evento_id,
            'liga': liga,
            'jogador_casa': jogador_casa,
            'jogador_visitante': jogador_visitante,
            'placar': ss_basico,
            'fase': fase,
            'entrada_segura': entrada_segura,
            'prioridade': prioridade,
            'evento_completo': evento
        }
        
        # FILTRO ULTRA RIGOROSO - S√ì APROVA PRIORIDADE EXATAMENTE 4
        if entrada_segura and prioridade == 4:
            emoji = "üü¢"  # Verde - Aprovado  
            status = "APROVADO"
            incluir_partida = True
        else:
            emoji = "üî¥"  # Vermelho - Rejeitado
            if prioridade > 4:
                status = f"REJEITADO (Prio {prioridade} - 3¬∫ set rejeitado)"
            else:
                status = f"REJEITADO (Prio {prioridade})"
            incluir_partida = False
        
        print(f"{emoji} PARTIDA {i} - {status}")
        print(f"   ID: {evento_id}")
        print(f"   üèüÔ∏è  Liga: {liga}")
        print(f"   üë§ {jogador_casa} vs {jogador_visitante}")
        print(f"   üéØ Games: {ss_basico}")
        print(f"   ‚è±Ô∏è  Fase: {fase}")
        print(f"   üìä Prioridade: {prioridade}/5 | Segura: {'‚úÖ' if entrada_segura else '‚ùå'}")
        
        # INCLUIR APENAS SE APROVADO
        if incluir_partida:
            partidas_filtradas.append(partida_info)
            print(f"   ‚úÖ INCLU√çDA")
        else:
            print(f"   ‚ùå REJEITADA - Timing insuficiente")
        
        print("-" * 60)
    
    # Resumo
    print("\n" + "=" * 80)
    print("üìä RESUMO DO FILTRO DE TIMING RIGOROSO")
    print("=" * 80)
    print(f"üéæ Total de partidas analisadas: {len(eventos_ao_vivo)}")
    print(f"üü¢ Partidas aprovadas (prioridade = 4): {len(partidas_filtradas)}")
    print(f"‚ùå Partidas rejeitadas: {len(eventos_ao_vivo) - len(partidas_filtradas)}")
    
    # Ordenar por prioridade (decrescente)
    partidas_filtradas.sort(key=lambda x: x['prioridade'], reverse=True)
    
    if partidas_filtradas:
        print("\nüéØ PARTIDAS APROVADAS (ordenadas por prioridade):")
        print("=" * 50)
        
        for i, partida in enumerate(partidas_filtradas[:10], 1):
            emoji_prio = "üü¢" if partida['prioridade'] >= 4 else "üîµ"
            print(f"{emoji_prio} {i}. {partida['jogador_casa']} vs {partida['jogador_visitante']}")
            print(f"      Prioridade: {partida['prioridade']}/5 | Fase: {partida['fase']}")
    
    print(f"\nüïê √öltima atualiza√ß√£o: {datetime.now().strftime('%H:%M:%S')}")
    print("üî¥ FILTRO ULTRA RIGOROSO ATIVO - Apenas prioridade = 4")
    
    return partidas_filtradas

def explicar_criterios():
    """Explica os crit√©rios de timing usados no filtro."""
    
    print("\nüìö CRIT√âRIOS DE TIMING PARA ENTRADA SEGURA")
    print("=" * 60)
    print("üü¢ EXCELENTE (Prioridade 5):")
    print("   ‚Ä¢ 3¬∫ set - qualquer ponto equilibrado")
    print("   ‚Ä¢ Fase decisiva, domin√¢ncia t√©cnica se destaca")
    print("")
    print("üîµ √ìTIMO (Prioridade 4):")
    print("   ‚Ä¢ 2¬∫ set - meio (3x3 a 5x5)")
    print("   ‚Ä¢ Odds estabilizadas, jogadores testados")
    print("")
    print("üü° BOM (Prioridade 3) - M√çNIMO ACEITO:")
    print("   ‚Ä¢ 2¬∫ set - in√≠cio (0x0 at√© 2x2)")
    print("   ‚Ä¢ ‚úÖ J√° temos dados do 1¬∫ set para an√°lise")
    print("")
    print("üü† POSS√çVEL (Prioridade 2) - REJEITADO:")
    print("   ‚Ä¢ 1¬∫ set - meio (3x3 at√© 5x5)")
    print("   ‚Ä¢ ‚ùå Filtro rigoroso, preferimos mais dados")
    print("")
    print("üî¥ EVITAR (Prioridade 0-1):")
    print("   ‚Ä¢ 1¬∫ set in√≠cio (0x0 at√© 2x2)")
    print("   ‚Ä¢ Tie-breaks (6x6)")
    print("   ‚Ä¢ Match points")
    print("   ‚Ä¢ Padr√£o t√°tico ainda n√£o claro")

if __name__ == "__main__":
    print("üéæ SISTEMA DE FILTRO DE TIMING - TENNIS IQ")
    print("=" * 50)
    
    explicar_criterios()
    print("\n" + "=" * 50)
    
    partidas = filtrar_partidas_por_timing()
    
    if partidas:
        print(f"\n‚úÖ {len(partidas)} partidas aprovadas para an√°lise!")
    else:
        print("\n‚ùå Nenhuma partida aprovada no momento.")
        print("üîÑ Aguarde partidas entrarem no 2¬∫ set ou mais.")
